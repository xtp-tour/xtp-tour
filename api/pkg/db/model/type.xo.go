package model

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql/driver"
	"fmt"
)

// Type is the 'type' enum type from schema 'xtp_tour'.
type Type uint16

// Type values.
const (
	// TypeIndoor is the 'indoor' type.
	TypeIndoor Type = 1
	// TypeOutdoor is the 'outdoor' type.
	TypeOutdoor Type = 2
	// TypeTent is the 'tent' type.
	TypeTent Type = 3
	// TypeBalloon is the 'balloon' type.
	TypeBalloon Type = 4
	// TypeBaloon is the 'baloon' type.
	TypeBaloon Type = 5
)

// String satisfies the [fmt.Stringer] interface.
func (t Type) String() string {
	switch t {
	case TypeIndoor:
		return "indoor"
	case TypeOutdoor:
		return "outdoor"
	case TypeTent:
		return "tent"
	case TypeBalloon:
		return "balloon"
	case TypeBaloon:
		return "baloon"
	}
	return fmt.Sprintf("Type(%d)", t)
}

// MarshalText marshals [Type] into text.
func (t Type) MarshalText() ([]byte, error) {
	return []byte(t.String()), nil
}

// UnmarshalText unmarshals [Type] from text.
func (t *Type) UnmarshalText(buf []byte) error {
	switch str := string(buf); str {
	case "indoor":
		*t = TypeIndoor
	case "outdoor":
		*t = TypeOutdoor
	case "tent":
		*t = TypeTent
	case "balloon":
		*t = TypeBalloon
	case "baloon":
		*t = TypeBaloon
	default:
		return ErrInvalidType(str)
	}
	return nil
}

// Value satisfies the [driver.Valuer] interface.
func (t Type) Value() (driver.Value, error) {
	return t.String(), nil
}

// Scan satisfies the [sql.Scanner] interface.
func (t *Type) Scan(v interface{}) error {
	switch x := v.(type) {
	case []byte:
		return t.UnmarshalText(x)
	case string:
		return t.UnmarshalText([]byte(x))
	}
	return ErrInvalidType(fmt.Sprintf("%T", v))
}

// NullType represents a null 'type' enum for schema 'xtp_tour'.
type NullType struct {
	Type Type
	// Valid is true if [Type] is not null.
	Valid bool
}

// Value satisfies the [driver.Valuer] interface.
func (nt NullType) Value() (driver.Value, error) {
	if !nt.Valid {
		return nil, nil
	}
	return nt.Type.Value()
}

// Scan satisfies the [sql.Scanner] interface.
func (nt *NullType) Scan(v interface{}) error {
	if v == nil {
		nt.Type, nt.Valid = 0, false
		return nil
	}
	err := nt.Type.Scan(v)
	nt.Valid = err == nil
	return err
}

// ErrInvalidType is the invalid [Type] error.
type ErrInvalidType string

// Error satisfies the error interface.
func (err ErrInvalidType) Error() string {
	return fmt.Sprintf("invalid Type(%s)", string(err))
}
