package model

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// UserPref represents a row from 'xtp_tour.user_pref'.
type UserPref struct {
	UID      string         `json:"uid"`      // uid
	Language string         `json:"language"` // language
	Country  string         `json:"country"`  // country
	City     sql.NullString `json:"city"`     // city
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [UserPref] exists in the database.
func (up *UserPref) Exists() bool {
	return up._exists
}

// Deleted returns true when the [UserPref] has been marked for deletion
// from the database.
func (up *UserPref) Deleted() bool {
	return up._deleted
}

// Insert inserts the [UserPref] to the database.
func (up *UserPref) Insert(ctx context.Context, db DB) error {
	switch {
	case up._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case up._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO xtp_tour.user_pref (` +
		`uid, language, country, city` +
		`) VALUES (` +
		`?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, up.UID, up.Language, up.Country, up.City)
	if _, err := db.ExecContext(ctx, sqlstr, up.UID, up.Language, up.Country, up.City); err != nil {
		return logerror(err)
	}
	// set exists
	up._exists = true
	return nil
}

// Update updates a [UserPref] in the database.
func (up *UserPref) Update(ctx context.Context, db DB) error {
	switch {
	case !up._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case up._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE xtp_tour.user_pref SET ` +
		`language = ?, country = ?, city = ? ` +
		`WHERE uid = ?`
	// run
	logf(sqlstr, up.Language, up.Country, up.City, up.UID)
	if _, err := db.ExecContext(ctx, sqlstr, up.Language, up.Country, up.City, up.UID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [UserPref] to the database.
func (up *UserPref) Save(ctx context.Context, db DB) error {
	if up.Exists() {
		return up.Update(ctx, db)
	}
	return up.Insert(ctx, db)
}

// Upsert performs an upsert for [UserPref].
func (up *UserPref) Upsert(ctx context.Context, db DB) error {
	switch {
	case up._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO xtp_tour.user_pref (` +
		`uid, language, country, city` +
		`) VALUES (` +
		`?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`uid = VALUES(uid), language = VALUES(language), country = VALUES(country), city = VALUES(city)`
	// run
	logf(sqlstr, up.UID, up.Language, up.Country, up.City)
	if _, err := db.ExecContext(ctx, sqlstr, up.UID, up.Language, up.Country, up.City); err != nil {
		return logerror(err)
	}
	// set exists
	up._exists = true
	return nil
}

// Delete deletes the [UserPref] from the database.
func (up *UserPref) Delete(ctx context.Context, db DB) error {
	switch {
	case !up._exists: // doesn't exist
		return nil
	case up._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM xtp_tour.user_pref ` +
		`WHERE uid = ?`
	// run
	logf(sqlstr, up.UID)
	if _, err := db.ExecContext(ctx, sqlstr, up.UID); err != nil {
		return logerror(err)
	}
	// set deleted
	up._deleted = true
	return nil
}

// UserPrefByUID retrieves a row from 'xtp_tour.user_pref' as a [UserPref].
//
// Generated from index 'user_pref_uid_pkey'.
func UserPrefByUID(ctx context.Context, db DB, uid string) (*UserPref, error) {
	// query
	const sqlstr = `SELECT ` +
		`uid, language, country, city ` +
		`FROM xtp_tour.user_pref ` +
		`WHERE uid = ?`
	// run
	logf(sqlstr, uid)
	up := UserPref{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, uid).Scan(&up.UID, &up.Language, &up.Country, &up.City); err != nil {
		return nil, logerror(err)
	}
	return &up, nil
}

// User returns the User associated with the [UserPref]'s (UID).
//
// Generated from foreign key 'user_pref_ibfk_1'.
func (up *UserPref) User(ctx context.Context, db DB) (*User, error) {
	return UserByUID(ctx, db, up.UID)
}
