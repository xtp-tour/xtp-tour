package model

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// PriceRule represents a row from 'xtp_tour.price_rules'.
type PriceRule struct {
	ID            int     `json:"id"`              // id
	PricePeriodID int     `json:"price_period_id"` // price_period_id
	DayPattern    string  `json:"day_pattern"`     // e.g., "*" (everyday except those specified), "st" (Saturday), "su" (Sunday), "hl" (Holiday), "!" (everyday force)
	TimeStart     string  `json:"time_start"`      // time_start
	TimeEnd       string  `json:"time_end"`        // time_end
	Price         float64 `json:"price"`           // price
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [PriceRule] exists in the database.
func (pr *PriceRule) Exists() bool {
	return pr._exists
}

// Deleted returns true when the [PriceRule] has been marked for deletion
// from the database.
func (pr *PriceRule) Deleted() bool {
	return pr._deleted
}

// Insert inserts the [PriceRule] to the database.
func (pr *PriceRule) Insert(ctx context.Context, db DB) error {
	switch {
	case pr._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case pr._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO xtp_tour.price_rules (` +
		`price_period_id, day_pattern, time_start, time_end, price` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, pr.PricePeriodID, pr.DayPattern, pr.TimeStart, pr.TimeEnd, pr.Price)
	res, err := db.ExecContext(ctx, sqlstr, pr.PricePeriodID, pr.DayPattern, pr.TimeStart, pr.TimeEnd, pr.Price)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	pr.ID = int(id)
	// set exists
	pr._exists = true
	return nil
}

// Update updates a [PriceRule] in the database.
func (pr *PriceRule) Update(ctx context.Context, db DB) error {
	switch {
	case !pr._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case pr._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE xtp_tour.price_rules SET ` +
		`price_period_id = ?, day_pattern = ?, time_start = ?, time_end = ?, price = ? ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, pr.PricePeriodID, pr.DayPattern, pr.TimeStart, pr.TimeEnd, pr.Price, pr.ID)
	if _, err := db.ExecContext(ctx, sqlstr, pr.PricePeriodID, pr.DayPattern, pr.TimeStart, pr.TimeEnd, pr.Price, pr.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [PriceRule] to the database.
func (pr *PriceRule) Save(ctx context.Context, db DB) error {
	if pr.Exists() {
		return pr.Update(ctx, db)
	}
	return pr.Insert(ctx, db)
}

// Upsert performs an upsert for [PriceRule].
func (pr *PriceRule) Upsert(ctx context.Context, db DB) error {
	switch {
	case pr._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO xtp_tour.price_rules (` +
		`id, price_period_id, day_pattern, time_start, time_end, price` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`price_period_id = VALUES(price_period_id), day_pattern = VALUES(day_pattern), time_start = VALUES(time_start), time_end = VALUES(time_end), price = VALUES(price)`
	// run
	logf(sqlstr, pr.ID, pr.PricePeriodID, pr.DayPattern, pr.TimeStart, pr.TimeEnd, pr.Price)
	if _, err := db.ExecContext(ctx, sqlstr, pr.ID, pr.PricePeriodID, pr.DayPattern, pr.TimeStart, pr.TimeEnd, pr.Price); err != nil {
		return logerror(err)
	}
	// set exists
	pr._exists = true
	return nil
}

// Delete deletes the [PriceRule] from the database.
func (pr *PriceRule) Delete(ctx context.Context, db DB) error {
	switch {
	case !pr._exists: // doesn't exist
		return nil
	case pr._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM xtp_tour.price_rules ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, pr.ID)
	if _, err := db.ExecContext(ctx, sqlstr, pr.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	pr._deleted = true
	return nil
}

// PriceRulesByPricePeriodID retrieves a row from 'xtp_tour.price_rules' as a [PriceRule].
//
// Generated from index 'idx_price_rules_price_period'.
func PriceRulesByPricePeriodID(ctx context.Context, db DB, pricePeriodID int) ([]*PriceRule, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, price_period_id, day_pattern, time_start, time_end, price ` +
		`FROM xtp_tour.price_rules ` +
		`WHERE price_period_id = ?`
	// run
	logf(sqlstr, pricePeriodID)
	rows, err := db.QueryContext(ctx, sqlstr, pricePeriodID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PriceRule
	for rows.Next() {
		pr := PriceRule{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&pr.ID, &pr.PricePeriodID, &pr.DayPattern, &pr.TimeStart, &pr.TimeEnd, &pr.Price); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pr)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PriceRuleByID retrieves a row from 'xtp_tour.price_rules' as a [PriceRule].
//
// Generated from index 'price_rules_id_pkey'.
func PriceRuleByID(ctx context.Context, db DB, id int) (*PriceRule, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, price_period_id, day_pattern, time_start, time_end, price ` +
		`FROM xtp_tour.price_rules ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, id)
	pr := PriceRule{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&pr.ID, &pr.PricePeriodID, &pr.DayPattern, &pr.TimeStart, &pr.TimeEnd, &pr.Price); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PricePeriod returns the PricePeriod associated with the [PriceRule]'s (PricePeriodID).
//
// Generated from foreign key 'price_rules_ibfk_1'.
func (pr *PriceRule) PricePeriod(ctx context.Context, db DB) (*PricePeriod, error) {
	return PricePeriodByID(ctx, db, pr.PricePeriodID)
}
